### Q. 列举常用的并发操作API和工具类，简单分析其使用场景和优缺点

#### CountDownLatch/CyclicBarrier

> 场景：任务A、B、C、D中，前三个任务可以同时执行，先后顺序没有影响，三者的共同结果用于D任务，那么可以启用多个线程，异步执行A、B、C三个任务，确保任务完成，再执行D任务

> 优点：可以确保前继任务完成之后，再启动后续任务的执行
>
> 缺点：需要人为的通过CountDownLatch/CyclicBarrier管理各个线程的同步关系，要注意出现异常导致线程永久阻塞的情况

#### CompletableFuture

>场景：异步编程的一站式解决方案，提供了变化结果、消费结果、组合、竞争、异常处理等解决方案

> 优点：
>
> ​		提供了工具化的接口，解决了各种线程同步异步执行关系；
>
> ​		无须维护线程池的创建和销毁
>
> 缺点：
>
> ​		实现较为复杂，
>
> ​		如果没有明确指定线程池，那么默认使用一个全局的ForkJoinPool，需要注意一个线程池被CPU密集和IO密集型任务混合使用导致性能低下的问题

#### CompletionService

> 场景：多个异步执行的任务，任务开始执行后，想要获取返回结果，如果通过硬编码通过Future.get()阻塞等待，可能第一个阻塞等待的反而是耗时最长的任务，而此时其他的Future.get()可能已经有了结果，CompletionService通过阻塞队列，如果有结果放入阻塞队列，消费结果的线程在阻塞队列等待，那么可以保证第一时间获取到最先完成的任务结果

> 优点：
>
> ​		确保多个Future.get()阻塞操作，一定可以获取最先完成任务的结果
>
> 缺点：
>
> ​		由于采用阻塞队列获取异步执行结果，需要控制好从阻塞队列获取任务的次数，次数少了缺少某些处理结果，次数多了，则可能造成永久阻塞

### Q. 请思考：什么是并发？什么是高并发？实现高并发高可用系统需要考虑哪些因素，对于这些你是怎么理解的？ 

> 并发指的是同一时间有多个任务在执行
>
> 高并发则是同一时间内并发执行的线程数很多
>
> 实现一个高并发高可用的系统，就需要让系统达到高吞吐，低延迟，现代服务端系统一般瓶颈都在IO操作，特别是数据库的查询，可以引入缓存、ES等机制利用内存实现快速查询数据，增加吞吐量，降低延迟，如果机器性能处理不了并发，可以先考虑垂直扩展增加硬件能力，而后考虑横向扩展增加机器，提供集群服务，避免单机故障导致停止服务

### Q. 请思考：还有哪些跟并发类似/有关的场景和问题，有哪些可以借鉴的解决办法。 

> 1. 可以考虑将一个大的任务拆分成多个小任务执行，比如导出Excel操作，如果使用一个线程，一次性导出数据耗时就很久
> 2. 限流，控制某个接口或者某个用户在具体时间段内的访问次数，可以借助redis的原子操作累计访问次数